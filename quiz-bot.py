import logging
import random
import os
from dotenv import load_dotenv 
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    Application,
    ApplicationBuilder,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters
)
from telegram.error import BadRequest

# === CONFIG ===
# It's better to load the token from an environment variable
TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
if not TOKEN:
    print("CRITICAL: Bot token not found. Set TELEGRAM_BOT_TOKEN in your .env file or environment variables.")
    exit() # Exit if token is missing

QUIZ_FILE = 'tests.txt' # Make sure this file is in the same directory
QUESTIONS_PER_BATCH = 10

# === STATES ===
SELECTING_SUBJECT, QUIZ_IN_PROGRESS = range(2)

# === Logging ===
# Configure logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
# set higher logging level for httpx to avoid all GET and POST requests being logged
logging.getLogger("httpx").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)

# === Utils ===
def load_questions(file_path):
    """Loads questions from a text file into a dictionary by subject."""
    subjects = {}
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        logger.error(f"Error: Quiz file not found at {file_path}")
        return subjects # Return empty dict if file not found

    current_subject = None
    for block in content.strip().split('\n\n'):
        lines = block.strip().split('\n')

        # Check for subject line first
        if lines[0].startswith("Subject:"):
            try:
                current_subject = lines[0].split(":", 1)[1].strip()
                if current_subject: # Ensure subject name is not empty
                     subjects[current_subject] = [] # Initialize subject list
                     logger.info(f"Found subject: {current_subject}")
                else:
                    logger.warning(f"Found empty subject name in block: {block}")
                    current_subject = None # Reset if subject name is empty
            except IndexError:
                 logger.warning(f"Malformed Subject line: {lines[0]}")
                 current_subject = None
            continue # Move to the next block after processing subject line

        # Process question block only if we have a valid current subject
        if current_subject is None:
             logger.warning(f"Skipping block due to missing subject context: {block}")
             continue

        if len(lines) < 6:
            logger.warning(f"Skipping malformed block for subject '{current_subject}': {block}")
            continue

        # Ensure the subject key exists (it should due to the check above)
        if current_subject not in subjects:
             logger.error(f"Internal logic error: Subject '{current_subject}' not initialized.")
             continue # Should not happen

        try:
            q = lines[0]
            options = lines[1:5]
            answer_line = lines[5]
            # Ensure options look like "A) Text"
            if not all(len(opt) > 2 and opt[1] == ')' for opt in options):
                 logger.warning(f"Malformed options in block for subject '{current_subject}': {options}")
                 continue
            # Ensure answer line looks like "Answer: X"
            if not answer_line.startswith("Answer:"):
                 logger.warning(f"Malformed answer line for subject '{current_subject}': {answer_line}")
                 continue

            correct = answer_line.split(":", 1)[1].strip()

            subjects[current_subject].append({
                'question': q,
                'options': options, # Store options like "A) Option Text"
                'correct': correct # Store correct answer letter like "A"
            })
        except IndexError:
            logger.warning(f"Skipping block due to parsing error for subject '{current_subject}': {block}")
        except Exception as e:
            logger.error(f"Unexpected error parsing block for subject '{current_subject}': {e}\nBlock: {block}")

    logger.info(f"Loaded subjects: {list(subjects.keys())}")
    if not subjects:
        logger.warning("No subjects were loaded. Check tests.txt format and content.")
    return subjects

# === Bot Handlers (Async v20 Style) ===

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Sends a message with inline buttons to choose a quiz subject."""
    # Define your subjects manually here to avoid issues with file loading affecting buttons
    # Make sure these names EXACTLY match the keys generated by load_questions
    known_subjects = ["Math", "English"]

    keyboard = []
    # Check if questions were loaded successfully for the known subjects
    loaded_subjects = context.bot_data.get('questions', {})

    for subj in known_subjects:
        if subj in loaded_subjects:
             # Only add button if questions for this subject were actually loaded
            keyboard.append([InlineKeyboardButton(text=subj, callback_data=f"subj|{subj}")])
        else:
            logger.warning(f"Subject '{subj}' hardcoded in 'start' but not found in loaded questions. Skipping button.")

    # Add the random button only if there are *any* loaded questions
    if loaded_subjects:
        keyboard.append([InlineKeyboardButton(text="Random Questions", callback_data="random")])

    if not keyboard:
        await update.message.reply_text(
            "Sorry, no quiz subjects could be loaded. Please check the bot's configuration and the 'tests.txt' file."
        )
        return ConversationHandler.END

    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text("Choose a subject or get random questions:", reply_markup=reply_markup)
    return SELECTING_SUBJECT # Transition to the state where subject selection is handled


async def start_quiz(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handles the subject selection, loads questions, and starts the quiz."""
    query = update.callback_query
    await query.answer() # Acknowledge the button press
    data = query.data
    user_id = update.effective_user.id

    all_loaded_questions = context.bot_data.get('questions', {})
    questions_to_ask = []
    subject_name = "Unknown"

    if data.startswith("subj|"):
        subject_name = data.split("|", 1)[1]
        if subject_name in all_loaded_questions:
            questions_to_ask = list(all_loaded_questions[subject_name]) # Make a copy
            random.shuffle(questions_to_ask) # Shuffle questions for the subject
            logger.info(f"User {user_id} selected subject: {subject_name}")
        else:
            logger.error(f"User {user_id} clicked button for subject '{subject_name}', but questions not found in bot_data.")
            await query.edit_message_text(f"Sorry, an error occurred loading questions for '{subject_name}'. Please try /start again.")
            return ConversationHandler.END

    elif data == "random":
        subject_name = 'Random Mix'
        temp_list = []
        if not all_loaded_questions:
             logger.error(f"User {user_id} requested random questions, but no subjects were loaded.")
             await query.edit_message_text("Sorry, no questions are available to randomize. Please try /start again.")
             return ConversationHandler.END

        # Collect a sample from each subject to ensure variety
        # Adjust logic here if you want exactly N random questions overall
        target_per_subject = max(1, 40 // len(all_loaded_questions)) # Example: Aim for up to 40 total
        for subj_questions in all_loaded_questions.values():
             # Take min(target, available) questions from each subject
             count = min(target_per_subject, len(subj_questions))
             if count > 0:
                  temp_list.extend(random.sample(subj_questions, count))

        questions_to_ask = temp_list
        random.shuffle(questions_to_ask)
        logger.info(f"User {user_id} selected random questions. Total: {len(questions_to_ask)}")

    else:
        logger.warning(f"Received unexpected callback data in start_quiz: {data}")
        await query.edit_message_text("Sorry, something went wrong. Please try /start again.")
        return ConversationHandler.END

    if not questions_to_ask:
         logger.error(f"No questions selected for user {user_id} for subject/mode '{subject_name}'.")
         await query.edit_message_text("Sorry, no questions could be prepared for this selection. Please try /start again.")
         return ConversationHandler.END

    # Store quiz state in user_data (managed by the library)
    context.user_data['subject'] = subject_name
    context.user_data['questions'] = questions_to_ask
    context.user_data['index'] = 0
    context.user_data['score'] = 0 # Initialize score

    # Edit the original message to show the quiz is starting
    await query.edit_message_text(f"Starting quiz on: {subject_name}")

    # Send the first batch of questions
    await send_next_question_batch(update, context)
    return QUIZ_IN_PROGRESS # Transition to the quiz state


async def send_next_question_batch(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int | None:
    """Sends the next batch of questions to the user."""
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id # Get chat_id correctly

    # Retrieve state from user_data
    current_index = context.user_data.get('index', 0)
    questions = context.user_data.get('questions', [])
    total_questions = len(questions)

    if not questions:
        logger.error(f"send_next_question_batch called for user {user_id} but no questions found in user_data.")
        await context.bot.send_message(chat_id=chat_id, text="An error occurred, no questions found. Please /start again.")
        context.user_data.clear() # Clear potentially corrupted state
        return ConversationHandler.END

    if current_index >= total_questions:
        # Quiz finished
        score = context.user_data.get('score', 0)
        await context.bot.send_message(
            chat_id=chat_id,
            text=f"Quiz finished!\nYour score: {score}/{total_questions}"
        )
        context.user_data.clear() # Clear state after finishing
        return ConversationHandler.END

    # Determine the end index for the current batch
    end_index = min(current_index + QUESTIONS_PER_BATCH, total_questions)
    batch = questions[current_index:end_index]

    logger.info(f"Sending questions {current_index + 1}-{end_index} to user {user_id}")

    for i, q_data in enumerate(batch):
        # Calculate the actual index in the full questions list
        question_global_index = current_index + i

        # Create buttons for options
        options_buttons = []
        # Ensure options are strings like "A) Option"
        valid_options = [opt for opt in q_data.get('options', []) if isinstance(opt, str) and len(opt) > 2 and opt[1] == ')']
        if not valid_options:
             logger.error(f"Question at index {question_global_index} for user {user_id} has invalid options: {q_data.get('options')}")
             await context.bot.send_message(chat_id=chat_id, text=f"Skipping question {question_global_index + 1} due to an internal error (invalid options).")
             continue # Skip this question

        for opt in valid_options:
            option_letter = opt[0] # Get the letter (A, B, C, D)
            # Callback data format: "ans|question_index|selected_letter"
            callback_data = f"ans|{question_global_index}|{option_letter}"
            options_buttons.append(InlineKeyboardButton(opt, callback_data=callback_data))

        # Arrange buttons (e.g., 2 per row) - adjust as needed
        keyboard = [options_buttons[j:j + 2] for j in range(0, len(options_buttons), 2)]
        reply_markup = InlineKeyboardMarkup(keyboard)

        question_text = q_data.get('question', 'Error: Missing question text')
        await context.bot.send_message(
            chat_id=chat_id,
            text=f"{question_global_index + 1}. {question_text}", # Add question number
            reply_markup=reply_markup
        )

    # Update the index in user_data for the next batch
    context.user_data['index'] = end_index

    # If there are more questions after this batch, show "Next" button
    if end_index < total_questions:
        next_button_keyboard = [[InlineKeyboardButton("Next Batch", callback_data="next")]]
        await context.bot.send_message(
            chat_id=chat_id,
            text="Click to continue...",
            reply_markup=InlineKeyboardMarkup(next_button_keyboard)
        )
        return QUIZ_IN_PROGRESS # Stay in the quiz state
    else:
        # This was the last batch, finish up
        score = context.user_data.get('score', 0)
        await context.bot.send_message(
            chat_id=chat_id,
            text=f"Quiz finished!\nYour score: {score}/{total_questions}"
        )
        context.user_data.clear()
        return ConversationHandler.END


async def handle_answer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handles the user's answer to a question."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id

    try:
        _, qid_str, selected_letter = query.data.split("|")
        qid = int(qid_str) # Index of the question in the user's list
    except (ValueError, IndexError):
        logger.error(f"Invalid callback data received in handle_answer: {query.data}")
        await query.edit_message_text("Sorry, there was an error processing your answer. Please try the next question if available.")
        return QUIZ_IN_PROGRESS # Stay in quiz state

    questions = context.user_data.get("questions", [])
    if not questions or qid >= len(questions):
         logger.error(f"handle_answer called for user {user_id} but questions list is invalid or qid {qid} out of bounds.")
         await query.edit_message_text("Sorry, there was an error retrieving the question data. Please try /start again.")
         context.user_data.clear()
         return ConversationHandler.END

    question_data = questions[qid]
    correct_answer_letter = question_data.get('correct')
    question_text = question_data.get('question', '[Question text missing]')

    # Find the full text of the selected option
    selected_option_text = "[Option not found]"
    correct_option_text = "[Correct option not found]"
    for opt in question_data.get('options', []):
         if isinstance(opt, str) and len(opt) > 0:
             if opt.startswith(selected_letter):
                 selected_option_text = opt
             if opt.startswith(correct_answer_letter):
                 correct_option_text = opt


    feedback = ""
    if selected_letter == correct_answer_letter:
        feedback = "✅ Correct!"
        # Increment score only if answer was correct
        context.user_data['score'] = context.user_data.get('score', 0) + 1
    else:
        feedback = f"❌ Wrong! Correct was: {correct_option_text}"

    # Edit the original question message to show feedback
    updated_text = (
        f"{qid + 1}. {question_text}\n\n" # Add question number back
        f"{feedback}\n"
        f"You chose: {selected_option_text}"
    )

    try:
        await query.edit_message_text(text=updated_text, reply_markup=None) # Remove buttons after answering
    except BadRequest as e:
        # Handle cases where the message might be too old to edit, etc.
        logger.warning(f"Could not edit message for user {user_id}, qid {qid}: {e}")
        # Optionally send a new message with feedback if editing fails
        # await context.bot.send_message(chat_id=query.message.chat_id, text=updated_text)

    return QUIZ_IN_PROGRESS # Stay in the quiz state


async def handle_next(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int | None:
    """Handles the 'Next Batch' button press."""
    query = update.callback_query
    await query.answer()
    # Remove the "Click to continue..." message and its button
    try:
        await query.delete_message()
    except BadRequest as e:
         logger.warning(f"Could not delete 'Next Batch' prompt message: {e}")

    # Send the next batch of questions
    return await send_next_question_batch(update, context)


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancels and ends the conversation."""
    user = update.message.from_user
    logger.info("User %s canceled the conversation.", user.first_name)
    await update.message.reply_text(
        "Quiz canceled. You can start again anytime with /start."
    )
    context.user_data.clear() # Clear user state
    return ConversationHandler.END


async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Log the error and send a telegram message to notify the developer."""
    logger.error("Exception while handling an update:", exc_info=context.error)

    # Optionally send a notification to the user or developer
    if isinstance(update, Update) and update.effective_message:
         await update.effective_message.reply_text("Sorry, an unexpected error occurred. Please try again later or use /start.")


def main() -> None:
    """Start the bot."""
    # Load questions into bot_data at startup
    # bot_data is suitable for read-only data shared across all users
    loaded_questions = load_questions(QUIZ_FILE)
    if not loaded_questions:
         logger.critical(f"CRITICAL: No questions loaded from {QUIZ_FILE}. Bot might not function correctly.")
         # Decide if you want the bot to exit or run without questions
         # return # Uncomment to exit if no questions are loaded

    # Create the Application and pass it your bot's token.
    application = ApplicationBuilder().token(TOKEN).build()

    # Store loaded questions in bot_data
    application.bot_data['questions'] = loaded_questions
    logger.info(f"Stored {len(loaded_questions)} subjects in bot_data.")


    # Setup ConversationHandler using v20 syntax
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            SELECTING_SUBJECT: [
                CallbackQueryHandler(start_quiz, pattern="^subj\\|"),
                CallbackQueryHandler(start_quiz, pattern="^random$")
                # Add other potential entry points or handlers for this state if needed
            ],
            QUIZ_IN_PROGRESS: [
                CallbackQueryHandler(handle_answer, pattern="^ans\\|"),
                CallbackQueryHandler(handle_next, pattern="^next$")
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel)], # Allow users to cancel anytime
        # Optional: Add conversation timeout settings
        # conversation_timeout=...,
        # Optional: Define how state is stored (defaults to in-memory)
        # persistent=True, name="quiz_conversation" # Requires setting up persistence
    )

    # Add ConversationHandler to application that will be used for handling updates
    application.add_handler(conv_handler)

    # Add a generic error handler
    application.add_error_handler(error_handler)

    # Run the bot until the user presses Ctrl-C
    logger.info("Starting bot polling...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    main()
